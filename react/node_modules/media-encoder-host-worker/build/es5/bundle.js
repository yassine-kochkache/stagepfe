(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/regenerator'), require('extendable-media-recorder-wav-encoder-broker'), require('worker-factory'), require('@babel/runtime/helpers/slicedToArray')) :
    typeof define === 'function' && define.amd ? define(['@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/regenerator', 'extendable-media-recorder-wav-encoder-broker', 'worker-factory', '@babel/runtime/helpers/slicedToArray'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global._asyncToGenerator, global._regeneratorRuntime, global.extendableMediaRecorderWavEncoderBroker, global.workerFactory, global._slicedToArray));
})(this, (function (_asyncToGenerator, _regeneratorRuntime, extendableMediaRecorderWavEncoderBroker, workerFactory, _slicedToArray) { 'use strict';

    var createDeregisterEncoder = function createDeregisterEncoder(encoderBrokerRegistry, ports) {
      return function (port) {
        var regexAsString = ports.get(port);
        if (regexAsString === undefined) {
          throw new Error('There is no encoder stored which wraps this port.');
        }
        encoderBrokerRegistry["delete"](regexAsString);
        ports["delete"](port);
      };
    };

    var createFinishEncoding = function createFinishEncoding(closePort, removeEncoderInstance) {
      return function (encoderId) {
        var _removeEncoderInstanc = removeEncoderInstance(encoderId),
          _removeEncoderInstanc2 = _slicedToArray(_removeEncoderInstanc, 4),
          encoderBroker = _removeEncoderInstanc2[0],
          port = _removeEncoderInstanc2[1],
          isRecording = _removeEncoderInstanc2[2],
          sampleRate = _removeEncoderInstanc2[3];
        if (!isRecording) {
          return encoderBroker.encode(encoderId, null);
        }
        return new Promise(function (resolve) {
          port.onmessage = function (_ref) {
            var data = _ref.data;
            if (data.length === 0) {
              closePort(port);
              resolve(encoderBroker.encode(encoderId, null));
            } else {
              encoderBroker.record(encoderId, sampleRate, data);
            }
          };
        });
      };
    };

    var createGetEncoderInstance = function createGetEncoderInstance(encoderInstancesRegistry) {
      return function (encoderId) {
        var entry = encoderInstancesRegistry.get(encoderId);
        if (entry === undefined) {
          throw new Error('There was no instance of an encoder stored with the given id.');
        }
        return entry;
      };
    };

    var createInstantiateEncoder = function createInstantiateEncoder(closePort, encoderInstancesRegistry, pickCapableEncoderBroker) {
      return function (encoderId, mimeType, sampleRate) {
        if (encoderInstancesRegistry.has(encoderId)) {
          throw new Error("There is already an encoder registered with an id called \"".concat(encoderId, "\"."));
        }
        var encoderBroker = pickCapableEncoderBroker(mimeType);
        var _MessageChannel = new MessageChannel(),
          port1 = _MessageChannel.port1,
          port2 = _MessageChannel.port2;
        var entry = [encoderBroker, port1, true, sampleRate];
        encoderInstancesRegistry.set(encoderId, entry);
        port1.onmessage = function (_ref) {
          var data = _ref.data;
          if (data.length === 0) {
            closePort(port1);
            entry[2] = false;
          } else {
            encoderBroker.record(encoderId, sampleRate, data.map(function (channelDataOrNumberOfSamples) {
              return typeof channelDataOrNumberOfSamples === 'number' ? new Float32Array(channelDataOrNumberOfSamples) : channelDataOrNumberOfSamples;
            }));
          }
        };
        return port2;
      };
    };

    var createPickCapableEncoderBroker = function createPickCapableEncoderBroker(encoderBrokerRegistry) {
      return function (mimeType) {
        for (var _i = 0, _Array$from = Array.from(encoderBrokerRegistry.values()); _i < _Array$from.length; _i++) {
          var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),
            regex = _Array$from$_i[0],
            encoderBroker = _Array$from$_i[1];
          if (regex.test(mimeType)) {
            return encoderBroker;
          }
        }
        throw new Error('There is no encoder registered which could handle the given mimeType.');
      };
    };

    var createRegisterEncoder = function createRegisterEncoder(encoderBrokerRegistry, ports, wrap) {
      return /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(port) {
          var encoderBroker, regex, regexAsString;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                encoderBroker = wrap(port);
                _context.next = 3;
                return encoderBroker.characterize();
              case 3:
                regex = _context.sent;
                regexAsString = regex.toString();
                if (!(encoderBrokerRegistry.has(regexAsString) || ports.has(port))) {
                  _context.next = 7;
                  break;
                }
                throw new Error('There is already an encoder stored which handles exactly the same mime types.');
              case 7:
                encoderBrokerRegistry.set(regexAsString, [regex, encoderBroker]);
                ports.set(port, regexAsString);
                return _context.abrupt("return", regex);
              case 10:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }();
    };

    var createRemoveEncoderInstance = function createRemoveEncoderInstance(encoderInstancesRegistry, getEncoderInstance) {
      return function (encoderId) {
        var entry = getEncoderInstance(encoderId);
        encoderInstancesRegistry["delete"](encoderId);
        return entry;
      };
    };

    var createRequestPartialEncoding = function createRequestPartialEncoding(getEncoderInstance) {
      return function (encoderId, timeslice) {
        var _getEncoderInstance = getEncoderInstance(encoderId),
          _getEncoderInstance2 = _slicedToArray(_getEncoderInstance, 1),
          encoderBroker = _getEncoderInstance2[0];
        return encoderBroker.encode(encoderId, timeslice);
      };
    };

    var closePort = function closePort(port) {
      port.onmessage = null;
      port.close();
    };

    var encoderBrokerRegistry = new Map();
    var ports = new WeakMap();
    var deregisterEncoder = createDeregisterEncoder(encoderBrokerRegistry, ports);
    var encoderInstancesRegistry = new Map();
    var getEncoderInstance = createGetEncoderInstance(encoderInstancesRegistry);
    var removeEncoderInstance = createRemoveEncoderInstance(encoderInstancesRegistry, getEncoderInstance);
    var finishEncoding = createFinishEncoding(closePort, removeEncoderInstance);
    var pickCapableEncoderBroker = createPickCapableEncoderBroker(encoderBrokerRegistry);
    var instantiateEncoder = createInstantiateEncoder(closePort, encoderInstancesRegistry, pickCapableEncoderBroker);
    var registerEncoder = createRegisterEncoder(encoderBrokerRegistry, ports, extendableMediaRecorderWavEncoderBroker.wrap);
    var requestPartialEncoding = createRequestPartialEncoding(getEncoderInstance);
    workerFactory.createWorker(self, {
      deregister: function () {
        var _deregister = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
          var port;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                port = _ref.port;
                return _context.abrupt("return", {
                  result: deregisterEncoder(port)
                });
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function deregister(_x) {
          return _deregister.apply(this, arguments);
        }
        return deregister;
      }(),
      encode: function () {
        var _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {
          var encoderId, timeslice, arrayBuffers;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                encoderId = _ref2.encoderId, timeslice = _ref2.timeslice;
                if (!(timeslice === null)) {
                  _context2.next = 7;
                  break;
                }
                _context2.next = 4;
                return finishEncoding(encoderId);
              case 4:
                _context2.t0 = _context2.sent;
                _context2.next = 10;
                break;
              case 7:
                _context2.next = 9;
                return requestPartialEncoding(encoderId, timeslice);
              case 9:
                _context2.t0 = _context2.sent;
              case 10:
                arrayBuffers = _context2.t0;
                return _context2.abrupt("return", {
                  result: arrayBuffers,
                  transferables: arrayBuffers
                });
              case 12:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function encode(_x2) {
          return _encode.apply(this, arguments);
        }
        return encode;
      }(),
      instantiate: function instantiate(_ref3) {
        var encoderId = _ref3.encoderId,
          mimeType = _ref3.mimeType,
          sampleRate = _ref3.sampleRate;
        var port = instantiateEncoder(encoderId, mimeType, sampleRate);
        return {
          result: port,
          transferables: [port]
        };
      },
      register: function () {
        var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {
          var port;
          return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                port = _ref4.port;
                _context3.next = 3;
                return registerEncoder(port);
              case 3:
                _context3.t0 = _context3.sent;
                return _context3.abrupt("return", {
                  result: _context3.t0
                });
              case 5:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function register(_x3) {
          return _register.apply(this, arguments);
        }
        return register;
      }()
    });

}));
